### Phase 4: Context Injection & Artifact Cleaning (The "Janitor" & The "Librarian")

**Phase 4** is about two things:

1. **Cleaning:** Removing the repetitive junk that confuses the LLM (The Janitor).
2. **Enriching:** Adding invisible pointers so the LLM knows *where* it is in the document (The Librarian).

---

### 1. The Janitor: Artifact Cleaning

Every PDF has "administrative debris" that repeats on every page.

* *Headers:* "Q3 Report - Confidential"
* *Footers:* "Copyright 2024"
* *Page Numbers:* "Page 12 of 50"

**The Risk:** If a sentence flows from Page 1 to Page 2, and we leave the footer in, the LLM reads:

> *"The project was delayed due to lack of **Page 1 of 50 ACME Corp** resources."*

The LLM treats the bolded part as part of the sentence, which degrades reasoning.

#### Strategy A: Geometric Exclusion (The "Kill Zone")

Since this is a general-purpose app, we can assume headers are at the top and footers are at the bottom.

* **Logic:** Define a "Kill Zone."
* *Top Margin:* 0% to 8% of page height.
* *Bottom Margin:* 92% to 100% of page height.


* **Action:** Any text block completely contained within these zones is flagged for deletion.
* **Exception Safety:** We must check if the text is a **Section Header** (Large Font, Bold). If it’s big and bold, we keep it (it might be the chapter title). If it’s tiny and grey, we kill it.

#### Strategy B: Frequency Analysis (The "De-Duper")

This is the smartest generic way to find artifacts without guessing margins.

* **Logic:** We buffer 3 pages at a time.
* **Comparison:** We look at the first text block of Page 1, Page 2, and Page 3.
* **Match:** If `Text(Page 1) == Text(Page 2)` AND their Y-coordinates are similar...
* **Verdict:** It is a running header. Delete it from **all** pages.

---

### 2. The Librarian: Context Injection

Now that the text is clean, we need to add "metadata anchors." LLMs have a "Lost in the Middle" problem—they might hallucinate a fact from Page 50 appearing on Page 2.

#### A. The Page Tag (The Anchor)

We don't just want to know *that* a page break happened; we want to label it.

* **Standard Output:** `...end of sentence.\n\nStart of next sentence...` (Context lost).
* **Enriched Output:**
```markdown
...end of sentence.

---

Start of next sentence...

```


* **Why:** This allows you to prompt the LLM: *"Find the table on Page 12"* or *"Cite the page number where you found this revenue figure."*

#### B. The Global Header (The Frame)

We prepend a **YAML Frontmatter** block to the very top of the Markdown file. This "primes" the LLM with the document's identity before it reads a single word.

* **Logic:** Extract metadata from the PDF properties (Title, Author, Creation Date).
* **Output:**
```markdown
---
filename: "annual_report.pdf"
title: "2024 Fiscal Summary"
author: "Finance Dept"
processed_date: "2025-01-18"
---

# Document Starts Here...

```



---

### 3. Logic Flow for `processor.py`

Here is how we integrate Phase 4 into our code logic. We do this *after* text extraction but *before* saving the file.

```python
def post_process_markdown(raw_pages):
    """
    Input: List of strings (one string per page)
    Output: Single merged Markdown string with context tags
    """
    cleaned_text = []
    
    # 1. Artifact Analysis (Simple Geometric Method)
    # Note: PyMuPDF often lets you exclude rects, but here we filter the string lines.
    
    for page_num, page_text in enumerate(raw_pages, start=1):
        
        # 2. Inject Page Separator
        # We wrap it in XML comments or specific delimiters
        page_marker = f"\n\n\n---\n\n"
        
        # 3. Append to master stream
        cleaned_text.append(page_marker)
        cleaned_text.append(page_text)
        
    # 4. Global Header Injection
    metadata_block = "---\nSource: Uploaded PDF\n---\n"
    
    final_output = metadata_block + "".join(cleaned_text)
    
    return final_output

```