### Phase 3: Table Extraction (The Vector & Grid Analysis)

This is the hardest part of PDF processing. Phase 1 gave us words; Phase 2 gave us paragraphs. Phase 3 tries to reconstruct **Grids** from a file format that doesn't natively support them.

### 1. The Two Types of Tables

To an algorithm, there are only two kinds of tables. We need different strategies for each.

* **Type A: The Lattice (The Easy One)**
* These tables have explicit black lines (borders) separating rows and columns.
* *Strategy:* Detect the lines  Find intersections  Build cells.


* **Type B: The Stream (The Hard One)**
* These tables have NO lines. They just use whitespace alignment.
* *Strategy:* Detect alignment clusters  Project virtual columns.
---

### 2. The "Lattice" Algorithm (Line Detection)

This is the robust method `PyMuPDF` uses when it sees borders.

#### Step A: The Vector Scan

The parser scans the page for **Draw Commands** (paths, lines, rectangles).

* **Filter:** It ignores curves or diagonal lines. We only care about strict Vertical (`x1 == x2`) and Horizontal (`y1 == y2`) lines.
* **De-Noising:** It ignores tiny lines (e.g., bullet points or decorative dashes) by setting a minimum length threshold (e.g., "Must be > 10px long").

#### Step B: The "Intersection" Map

Once we have a pile of lines, we find where they cross.

* **Logic:** Every `+` intersection is a potential corner of a cell.
* **Cell Construction:** The algorithm essentially plays "Connect the Dots." It finds the smallest possible rectangle formed by 4 intersections.
* *Result:* We now have a list of empty boxes: `Rect(x=50, y=100, w=50, h=20)`.


#### Step C: The "Spatial Join" (Putting text in the box)

Now we bring the text back from Phase 1.

* **Loop:** For every text span on the page:
* **Check:** Does the *center point* of this text fall inside `Cell_42`?
* **Action:** If yes, assign that text to that cell.


* **The "Spill" Problem:** Sometimes text is slightly too long and crosses the line.
* *Fix:* We use a "Tolerance Margin." If the text overlaps the border by only 1-2 pixels, we force it back into the cell where it *started*.



---

### 3. The "Stream" Algorithm (Whitespace Analysis)

This is for general documents (like invoices or simple reports) that don't use grid lines.

#### Step A: The "Projection" Method

Imagine shining a flashlight from the top of the page down to the bottom.

* **Shadows:** Wherever there is text, there is a shadow.
* **Light:** Wherever there is a "gap" (whitespace) all the way down, the light passes through.
* **Conclusion:** If light passes through at `x=100` and `x=250` for the entire height of a block, those are your **Column Boundaries**.

#### Step B: Row Detection

We do the same thing horizontally.

* Shine a light from Left to Right.
* Gaps between lines of text define the **Rows**.

*Critique:* This method is fragile. If a single word in Row 3 is too long and crosses into the "gap," the algorithm thinks the column doesn't exist. This is why "Stream" extraction often fails on messy docs.

---

### 4. The Transformation: Flattening to Markdown

We have the cells. Now we need to print them. Markdown is very limited (it's just text with pipes `|`), so we have to make compromises.

#### A. The "Merged Cell" Compromise

* **Scenario:** A header "Q3 Financials" spans across 3 columns.
* **Problem:** Markdown doesn't support `colspan=3`.
* **Algorithm Action:** We must "flatten" it. We have two choices:
1. **Repeat:** `| Q3 Financials | Q3 Financials | Q3 Financials |` (Ugly, but keeps context).
2. **Empty:** `| Q3 Financials | | |` (Standard).


* *Decision:* For LLMs, **Repeating** is actually often better because the LLM reads token-by-token. But for general readability, **Empty** is standard. We usually stick to Empty.



#### B. The "Multi-line Row" Problem

* **Scenario:**
```
| Item       | Description          |
| Apple      | A very delicious red |
|            | fruit from trees.    |

```


* **Problem:** Is "fruit from trees" a new row? Or part of the "Apple" row?
* **Algorithm Action:**
* We look for the **Horizontal Line** separator.
* If there is *no line* between "red" and "fruit", we treat it as a newline `\n` *inside* the same cell.
* *Markdown Output:* `| Apple | A very delicious red<br>fruit from trees. |` (We use HTML break tags inside Markdown tables).



---

### 5. Summary of Phase 3 Logic

For our **General Purpose Lite App**, we will default to **Lattice Mode** (Line Detection) because it is high-precision.

If no lines are detected, we usually **skip table extraction** and just treat it as text (Phase 2), rather than risking the hallucinations of "Stream Mode."

**Logic Flow for `processor.py`:**

```python
def extract_tables(page):
    # 1. Look for vector lines
    tables = page.find_tables(strategy="lines_strict") 
    
    if not tables:
        # Fallback: Don't guess. Just return text blocks.
        return None

    markdown_tables = []
    for table in tables:
        # 2. Extract content
        # PyMuPDF returns a list of lists: [ ["Col1", "Col2"], ["Val1", "Val2"] ]
        data = table.extract()
        
        # 3. Convert List-of-Lists to Markdown String
        md = convert_to_markdown_syntax(data)
        markdown_tables.append(md)
        
    return markdown_tables
