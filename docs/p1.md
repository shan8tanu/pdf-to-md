**Phase 1: The Bag of Words & The Stitcher**.

### 1. The Raw Input: What the Machine Sees

When `PyMuPDF` reads a page, it doesn't see a paragraph. It sees a list of **draw commands**.
Imagine a painter's logbook:

1. *Go to x=50, y=100. Select Font 'Arial 12'. Draw "Rev".*
2. *Go to x=65, y=100. Select Font 'Arial 12'. Draw "enue".*
3. *Go to x=200, y=100. Select Font 'Arial 12'. Draw "2025".*

To the machine, "Rev" and "enue" are just as unrelated as "Revenue" and "2025". They just happen to be neighbors.

### 2. The Algorithm: How the "Stitcher" Works

We need a set of heuristics (rules) to glue these independent atoms back into molecules (words) and then into organisms (sentences).

#### Rule A: The Vertical Baseline Check (The "Line" Logic)

First, we group things that are on the same "line."

* **Math:** `Abs(Span_A.y - Span_B.y) < Tolerance`
* **The Issue:** In PDFs, "subscripts" (like in CO$_2$) or slightly misaligned text (badly formatted tables) might sit 1 pixel lower.
* **Ideation/Fix:** We cannot demand exact equality (). We need a **vertical tolerance** (epsilon).
* *If `Span_B` is within ±2 pixels of `Span_A`'s vertical baseline, treat them as the same line.*



#### Rule B: The Horizontal Proximity Check (The "Kerning" Logic)

This is where "Rev" + "enue" happens.

* **Math:** `Distance = Span_B.x_start - Span_A.x_end`
* **The Threshold:** We need to define a "Space Width."
* If `Distance` is approx 0 (or very small), it's a **split word** (Kerning).  **Action:** Merge ("Revenue").
* If `Distance` is approx `Font_Size / 3`, it's a **space**.  **Action:** Add space ("Revenue 2025").
* If `Distance` is huge, it's a **Tab/Column break**.  **Action:** Separate block.



### 3. Common Financial Failures in Phase 1

**1. The "Negative Number" Trap**

* **Scenario:** Financial tables often show negative numbers as `( 500 )` or `- 500`.
* **The PDF:** Often draws the `-` as a separate object from `500`.
* **Stitcher Failure:** If the space is too wide, the LLM reads it as a bullet point `-` and then the number `500`. The "negativity" is lost.
* **Fix:** We need a specific heuristic: *If a span is just "-" and the next span is a Number, merge them regardless of the whitespace gap.*

**2. The "Justified Text" Nightmare**

* **Scenario:** In formal reports, text is often "Justified" (aligned to both left and right margins).
* **The PDF:** To achieve this, the PDF stretches spaces between words unevenly. "The     market     is     bullish."
* **Stitcher Failure:** The algorithm sees big gaps and assumes they are separate data columns, not a sentence.
* **Fix:** We calculate the **Average Character Width** for that line. If the gap is less than `3 * Avg_Char_Width`, we force it to remain a sentence.

**3. The "Floating Currency" Symbol**

* **Scenario:**
```
$       5,000,000

```


(The dollar sign is way over on the left).
* **Stitcher Failure:** The parser reads this as two separate columns: Column 1 is `$` (useless), Column 2 is `5,000,000`. The LLM loses the currency context.
* **Fix:** Similar to the negative sign. If a span is a currency symbol (`$`, `₹`) and is isolated, "pull" it towards the nearest number on the right.

### 4. Ideation: How to Implement This?

We don't actually have to write this raw math from scratch (thankfully). `PyMuPDF` has a flag called `flags=fitz.TEXT_PRESERVE_LIGATURES | fitz.TEXT_PRESERVE_WHITESPACE`.

However, for your "Pro" version, we might want to run a **second pass** after the library does its best guess.

**The Logic Flow for your Processor:**

1. **Extract:** Get all text spans.
2. **Sort:** Sort by Y (Top-down), then X (Left-Right).
3. **Loop:**
```python
if (Current_Span.x - Previous_Span.end_x) < TINY_THRESHOLD:
    Merge(Previous, Current) # Fixes "Rev"-"enue"
elif (Current_Span.x - Previous_Span.end_x) < SPACE_THRESHOLD:
    Append(" ", Current)     # Normal Sentence
else:
    New_Column(Current)      # It's a table column or new block

```