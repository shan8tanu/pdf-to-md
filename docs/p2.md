### Phase 2: Block Detection & The "River" Logic

We need to group those lines into semantic units (Paragraphs, Headers, Lists) and, crucially, decide the **Reading Order**.

This is the phase where most simple RAG (Retrieval-Augmented Generation) pipelines fail. If you get this wrong, you feed the LLM a schizophrenia simulation where a sentence starts in Column A and finishes in Column B, with a page number inserted in the middle.

---

### 1. The Core Concept: "The White River"

How do you know a page has two columns without "seeing" it? You look for the **White River**.

* **The Heuristic:** The algorithm scans the page vertically. If it finds a continuous vertical strip of whitespace (empty coordinate space) that runs from the top margin to the bottom margin, it cuts the page in half.
* **The Decision:**
* *No River:* Standard Page (Read Left  Right, Top  Bottom).
* *River Found:* Columnar Page. (Read Block A [Left], then Block B [Right]).



### 2. The Logic Steps (The "Sort" Problem)

#### A. Vertical Grouping (Making Paragraphs)

We have a list of lines. We need to decide: *Are these two lines part of the same paragraph, or is this a new paragraph?*

* **The Math:** We calculate the `Inter-Line Distance` (vertical gap).
* Let  be the average line height (font size).
* If : **Same Paragraph**. (Standard leading).
* If : **New Paragraph**.


* **The LLM Impact:** If you merge two distinct paragraphs, you might merge two conflicting ideas. If you split one paragraph, you break the semantic reasoning.

#### B. Reading Order (The N-Path vs. Z-Path)

This is the single biggest "garbage generator" in PDF processing.

* **The "Z-Path" (Naive):** Most basic parsers read strict Left-to-Right.
* *Result:* It reads Line 1 of Col A, then jumps to Line 1 of Col B.
* *Output:* "The company revenue (See Chart A) increased by 10%." -> *"The company revenue increased by (See Chart A) 10%."*


* **The "N-Path" (Correct):** We must force the algorithm to finish Column A before starting Column B.
* **The Algorithm:**
1. Detect the "White River" (Column Gap).
2. Assign a `Block_ID` to everything on the Left.
3. Assign a `Block_ID` to everything on the Right.
4. Sort by `Block_ID`, *then* by `Y-Coordinate`.





### 3. Financial Document Edge Cases (The "Gotchas")

Your IPO documents have specific layouts that break standard algorithms. Here is how we handle them in Phase 2.

#### Case 1: The "Spanning" Header

* **Scenario:** You have a 2-column layout, but the Section Title ("**RISK FACTORS**") is centered and spans across *both* columns.
* **The Bug:** The "White River" logic fails because the Header text blocks the river. The algorithm thinks the whole page is 1 column.
* **The Fix:** The **"Horizontal Cut"** rule.
* Before looking for columns, the algorithm looks for horizontal black lines (separators) or massive whitespace gaps.
* It cuts the page into "Zones" (Zone 1: Header, Zone 2: Body).
* *Then* it runs column detection on Zone 2 only.



#### Case 2: The "Floating" Sidebar / Callout

* **Scenario:** A grey box in the middle of the page with a quote or a specific "Key Metric" highlight.
* **The Bug:** The algorithm reads the main text, hits the box, reads the box contents, and then goes back to the main text.
* *Text:* "...the market is volatile. **EBITDA IS UP 5%** Therefore, we must..."


* **The Fix:** **Density Analysis**.
* If a block of text has a different background color (requires vector analysis) or is surrounded by a border box, we tag it as `Sidebar`.
* **Action:** We extract it, but we **move it to the end of the section** in the Markdown output so it doesn't interrupt the sentence flow.



#### Case 3: Footnotes (The Noise)

* **Scenario:** Small text at the bottom: "*1. Excluding one-time writes-offs.*"
* **The Bug:** It gets appended to the last paragraph of the page, confusing the LLM into thinking the footnote is part of the main argument.
* **The Fix:** **Y-Coordinate Thresholding**.
* Any text block found below the `Footer_Threshold` (e.g., bottom 10% of page) with a `Font_Size < Body_Text_Size` is tagged as `Footnote`.
* **Action:** In Markdown, we can format this as a formal footnote `[^1]` or simply move it to a "Notes" section at the end.



### 4. Implementation Ideation (Your "Lite" Engine)

Since we are using `PyMuPDF` (CPU only), we rely on `page.get_text("blocks")`.

The library actually does a decent job of clustering (Step A). Our work is mostly in **Step B (Sorting)**.

**The Logic Flow for `processor.py`:**

```python
def get_logical_blocks(page):
    # 1. Get raw blocks from PyMuPDF
    # Returns a list of tuples: (x0, y0, x1, y1, "text", block_no, block_type)
    raw_blocks = page.get_text("blocks")

    # 2. Separate into "Main Body" and "Artifacts"
    body_blocks = []
    headers = []
    
    for b in raw_blocks:
        if is_header(b): # Check font size/bold
            headers.append(b)
        elif is_footer(b): # Check Y-coordinate > 800
            continue # Delete it
        else:
            body_blocks.append(b)

    # 3. Detect Columns (The "River" Check)
    # We check if block X-coordinates cluster into two distinct groups (e.g., 50-250 and 300-500)
    if is_two_column(body_blocks):
        # Sort by Column (Left first), then by Y
        body_blocks.sort(key=lambda b: (b.x0 // column_width, b.y0))
    else:
        # Sort purely by Y
        body_blocks.sort(key=lambda b: b.y0)

    return headers + body_blocks

```